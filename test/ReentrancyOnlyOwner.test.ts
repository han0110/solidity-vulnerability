import { expect, use } from 'chai'
import { Contract, BigNumber } from 'ethers'
import { deployContract, MockProvider, solidity } from 'ethereum-waffle'
import * as ReentrancyOnlyOwner from '../build/ReentrancyOnlyOwner.json'
import * as ReentrancyAttack from '../build/ReentrancyAttack.json'
import * as LoggerEvil from '../build/LoggerEvil.json'

use(solidity)

describe('ReentrancyOnlyOwner', () => {
  const ether = BigNumber.from(10).pow(18)
  const provider = new MockProvider()
  const [walletA, walletB, nobody] = provider.getWallets()

  let reentrancy: Contract
  let reentrancyAttack: Contract

  beforeEach(async () => {
    const loggerEvil = await deployContract(walletA, LoggerEvil)
    reentrancy = await deployContract(walletA, ReentrancyOnlyOwner, [
      loggerEvil.address,
    ])
    reentrancyAttack = await deployContract(nobody, ReentrancyAttack)
  })

  //        BAIT + ATTACK
  // floor( ------------- ) mod 2 == 0 => root tx will succeed and cheat the hacker.
  //           ATTACK
  //
  //        BAIT + ATTACK
  // floor( ------------- ) mod 2 == 1 => root tx will revert.
  //           ATTACK

  it('should only be attackable by owner', async () => {
    // A deposits bait
    const bait = ether
    await expect(
      await reentrancy.deposit({ value: bait })
    ).to.changeEtherBalances([walletA, reentrancy], [bait.mul(-1), bait])

    // B performs an attack but reverted
    let hackerAttackEther = ether.div(100).mul(50)
    reentrancyAttack = reentrancyAttack.connect(walletB)
    await expect(
      reentrancyAttack.attack(reentrancy.address, { value: hackerAttackEther })
    ).to.be.reverted

    // B performs an attack and cheated
    hackerAttackEther = ether
    await expect(
      await reentrancyAttack.attack(reentrancy.address, {
        value: hackerAttackEther,
      })
    ).to.changeEtherBalances(
      [walletB, reentrancy, reentrancyAttack],
      [
        // B's attacking balance is stucked
        hackerAttackEther.mul(-1),
        hackerAttackEther,
        0,
      ]
    )

    // A performs an attack and succeeded
    const reentrancyBalance = await provider.getBalance(reentrancy.address)
    reentrancyAttack = reentrancyAttack.connect(walletA)
    await expect(
      await reentrancyAttack.attack(reentrancy.address, {
        value: reentrancyBalance,
      })
    ).to.changeEtherBalances(
      [walletA, reentrancy, reentrancyAttack],
      [
        reentrancyBalance.mul(-1),
        // A's bait + B's attacking ether
        reentrancyBalance.mul(-1),
        reentrancyBalance.mul(2),
      ]
    )
  })
})
