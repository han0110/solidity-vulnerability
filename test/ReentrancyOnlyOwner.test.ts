import { expect, use } from 'chai'
import { Contract, BigNumber } from 'ethers'
import { deployContract, MockProvider, solidity } from 'ethereum-waffle'
import * as ReentrancyOnlyOwner from '../build/ReentrancyOnlyOwner.json'
import * as ReentrancyAttack from '../build/ReentrancyAttack.json'
import * as LoggerEvil from '../build/LoggerEvil.json'

use(solidity)

describe('ReentrancyOnlyOwner', () => {
  const [walletA, walletB] = new MockProvider().getWallets()
  const ether = BigNumber.from(10).pow(18)
  let reentrancy: Contract

  beforeEach(async () => {
    const loggerEvil = await deployContract(walletA, LoggerEvil)
    reentrancy = await deployContract(walletA, ReentrancyOnlyOwner, [
      loggerEvil.address,
    ])
  })

  it('should only be attackable by owner', async () => {
    // A deposits 1 ether
    await expect(
      await reentrancy.deposit({ value: ether })
    ).to.changeEtherBalances([walletA, reentrancy], [ether.mul(-1), ether])
    expect(await reentrancy.balanceOf(walletA.address)).to.equal(ether)

    // B performs an attack
    let reentrancyAttack = await deployContract(walletB, ReentrancyAttack)
    await expect(
      await reentrancyAttack.attack(reentrancy.address, { value: ether })
    ).to.changeEtherBalances(
      [reentrancyAttack, reentrancy],
      [
        0,
        // B's attacking balance is stucked
        ether,
      ]
    )

    // A performs an attack
    reentrancyAttack = await deployContract(walletA, ReentrancyAttack)
    await expect(
      await reentrancyAttack.attack(reentrancy.address, { value: ether })
    ).to.changeEtherBalances(
      [reentrancyAttack, reentrancy],
      [
        // A's bait + B + A's attacking
        ether.mul(3),
        // A's bait + B's attacking balance
        ether.mul(-2),
      ]
    )
  })
})
